@model ComputerGraphicsProject.Models.HslModel;

<div class="fractal-container">
    <div class="fractal-pages__img-container">
        <img class="fractal-pages__img" id="fractalImage" src="@Url.Action("GetHslImage")" />
    </div>
    <a class="fractal-pages__dwnld-buttn-container" href="@Url.Action("GetHslImage", "ColorSchemes")" download="hsl.jpeg"></a>
</div>


<form asp-action="Hsl" enctype="multipart/form-data">
    <div class="fractal-pages__form-data">
        <label asp-for="H" class="fractal-pages__data-text">H = </label>
        <input asp-for="H" class="newton-page__form-data__real-img" style="max-width: 70px; margin-left: 5px; margin-right: 10px;" id="H"/>
        <label asp-for="S" class="fractal-pages__data-text">S = </label>
        <input asp-for="S" class="newton-page__form-data__real-img" style="max-width: 70px; margin-left: 5px;  margin-right: 10px;" id="S"/>
        <label asp-for="L" class="fractal-pages__data-text">L = </label>
        <input asp-for="L" class="newton-page__form-data__real-img" style="max-width: 70px; margin-left: 5px;  margin-right: 10px;" id="L"/>
        <input asp-for="File" type="file" class="form-control" style="width: 128px; margin-left: 20px;" />

    </div>
    <div class="fractal-pages__form-submit">
        <input class="fractal-pages__generate-button" type="submit" value="" />
    </div>
    <div class="fractal-pages__form-valid">
        <div asp-validation-summary="All" class="text-danger"></div>
    </div>
</form>
<div class="bg-photo"></div>


<!--
<script>
    document.addEventListener("DOMContentLoaded", function () {
        var image = document.getElementById("fractalImage");

        var image = document.getElementById("fractalImage");
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        var imageData;

        image.onload = function () {
            canvas.width = image.width;
            canvas.height = image.height;
            ctx.drawImage(image, 0, 0, image.width, image.height);

            // Тепер ви можете викликати getImageData
            imageData = getImageData();
            console.log(imageData);
        };

        var selection = {
            isSelecting: false,
            startX: 0,
            startY: 0,
            endX: 0,
            endY: 0
        };

        image.addEventListener("mousedown", function (event) {
            if (!selection.isSelecting) {
                // Починаємо виділення
                selection.isSelecting = true;
                selection.startX = event.clientX - image.getBoundingClientRect().left;
                selection.startY = event.clientY - image.getBoundingClientRect().top;
            } else {
                // Завершуємо виділення
                selection.isSelecting = false;
                selection.endX = event.clientX - image.getBoundingClientRect().left;
                selection.endY = event.clientY - image.getBoundingClientRect().top;

                console.log(selection);
                
                var formData = new FormData();
                formData.append("fullImageData", getImageData());
                formData.append("startX", parseInt(selection.startX));
                formData.append("startY", parseInt(selection.startY));
                formData.append("endX", parseInt(selection.endX));
                formData.append("endY", parseInt(selection.endY));
                formData.append("height", image.height);
                formData.append("width", image.width);

                // Отправка масивів байтів на сервер за допомогою AJAX-запиту
                sendImageDataToServer(formData);
                
            }
        });

        function sendImageDataToServer(formData) {
            console.log(formData);
            // Відправка масивів байтів на сервер за допомогою AJAX-запиту
            $.ajax({
                url: "/ColorSchemes/GetImageData",
                type: "POST",
                processData: false,  // Важливо встановити параметр processData в false
                contentType: false,  // Важливо встановити параметр contentType в false
                data: formData,
                success: function (response) {
                    // Оновлення параметрів на сторінці або інші дії
                    console.log("Server response:", response);
                },
                error: function (error) {
                    console.error("Error sending image data to the server:", error);
                }
            });
        }

        function getImageData() {
            var imageData = ctx.getImageData(0, 0, image.width, image.height).data;


            // Перетворення у формат [R, G, B] для кожного пікселя
            var bytes = [];
            for (var i = 0; i < imageData.length; i += 4) {
                var red = imageData[i];
                var green = imageData[i + 1];
                var blue = imageData[i + 2];

                bytes.push(red, green, blue);
            }

            return bytes;
        }

        function todo()
        {

        }
    });


</script>
-->

<script>
    document.addEventListener("DOMContentLoaded", function () {
        var image = document.getElementById("fractalImage");
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");

        var selectedCanvas;

        var selection = {
            isSelecting: false,
            startX: 0,
            startY: 0,
            endX: 0,
            endY: 0
        };

        image.addEventListener("mousedown", function (event) {
            if (!selection.isSelecting) {
                // Починаємо виділення
                selection.isSelecting = true;
                selection.startX = event.clientX - image.getBoundingClientRect().left;
                selection.startY = event.clientY - image.getBoundingClientRect().top;
                selection.startX = parseInt(selection.startX);
                selection.startY = parseInt(selection.startY);

            } else {
                // Завершуємо виділення
                selection.isSelecting = false;
                selection.endX = event.clientX - image.getBoundingClientRect().left;
                selection.endY = event.clientY - image.getBoundingClientRect().top;
                selection.endX = parseInt(selection.endX);
                selection.endY = parseInt(selection.endY);

                ctx.drawImage(image, 0, 0, image.width, image.height);
                console.log(canvas.width, canvas.height);



                // Отримання масиву байтів виділеної області
                var selectedImageData = getSelectedImageData();

                // Виклик функції для обробки даних на клієнті
                processImageData(selectedImageData);

                canvas.width = image.naturalWidth;
                canvas.height = image.naturalHeight

                // Отримати URL-представлення зображення з канвасу
                var imageDataUrl = canvas.toDataURL("image/png");

                // Встановити URL як джерело зображення для тегу img
                image.src = imageDataUrl;
            }
        });

        function getSelectedImageData() {
            // Отримання картинки з інпут-поля файлу
            selectedCanvas = document.createElement("canvas");
            selectedCanvas.width = selection.endX - selection.startX;
            selectedCanvas.height = selection.endY - selection.startY;
            var selectedCtx = selectedCanvas.getContext("2d");

            // Копіювання виділеної області на окремий canvas
            selectedCtx.drawImage(image, selection.startX, selection.startY, selectedCanvas.width, selectedCanvas.height, 0, 0, selectedCanvas.width, selectedCanvas.height);

            // Отримання об'єкта ImageData
            return selectedCtx.getImageData(0, 0, selectedCanvas.width, selectedCanvas.height);
        }

        function processImageData(imageData) {
            var hInput = document.getElementById("H");
            var sInput = document.getElementById("S");
            var lInput = document.getElementById("L");

            var pixelData = imageData.data;


            var bytes = [];
            for (var i = 0; i < pixelData.length; i += 4) {
                var red = pixelData[i];
                var green = pixelData[i + 1];
                var blue = pixelData[i + 2];

                var hsl = rgbToHslWithAdjustments(red, green, blue, hInput.value, sInput.value, lInput.value);
                var rgb = hslToRgb(hsl[0], hsl[1], hsl[2]);

                bytes.push(rgb[0], rgb[1], rgb[2], 255);
            }


            // Заміна зображення на канвасі із новими даними
            ctx.putImageData(new ImageData(new Uint8ClampedArray(bytes), selectedCanvas.width, selectedCanvas.height), selection.startX, selection.startY);
        }


        function hslToRgb(h, s, l) {
            // Перевірка коректності введених значень HSL
            h = (h + 360) % 360; // Забезпечення, що h знаходиться в межах [0, 360)
            s = Math.max(0, Math.min(100, s)) / 100; // Забезпечення, що s знаходиться в межах [0, 100]
            l = Math.max(0, Math.min(100, l)) / 100; // Забезпечення, що l знаходиться в межах [0, 100]

            // Функція для отримання значень RGB з HSL
            function hueToRgb(p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            }

            // Обчислення компонентів RGB
            let r, g, b;

            if (s === 0) {
                r = g = b = l; // Відтінок колірності відсутній, отже RGB рівні L
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hueToRgb(p, q, h / 360 + 1 / 3);
                g = hueToRgb(p, q, h / 360);
                b = hueToRgb(p, q, h / 360 - 1 / 3);
            }

            // Перетворення в [0, 255]
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }


        function rgbToHslWithAdjustments(red, green, blue, h, s, l) {
            // Нормалізація значень R, G, B до діапазону [0, 1]
            red /= 255;
            green /= 255;
            blue /= 255;

            // Знаходження максимального та мінімального значення
            const max = Math.max(red, green, blue);
            const min = Math.min(red, green, blue);

            // Обчислення відтінку (hue)
            var hue;
            if (max === min) {
                hue = 0; // Сірий колір, якщо R = G = B
            } else {
                const delta = max - min;
                if (max === red) {
                    hue = ((green - blue) / delta + (green < blue ? 6 : 0)) * 60;
                } else if (max === green) {
                    hue = ((blue - red) / delta + 2) * 60;
                } else {
                    hue = ((red - green) / delta + 4) * 60;
                }
            }

            // Додавання коригувань до відтінку (hue), насиченості (saturation) та світлоти (lightness)
            hue = parseInt(h);
            const saturation = Math.max(0, Math.min(100, s + ((max === 0 ? 0 : (max - min) / max) * 100)));
            const lightness = Math.max(0, Math.min(100, l + (((max + min) / 2) * 100)));

            // Повернення результату у вигляді об'єкта { h, s, l }

            return [ hue, saturation, lightness ];
        }

    });


</script>